# Тестовое задание от одной из компаний
Задание выглядит так:

**Напишите приложение, которое по REST принимает запрос вида**

POST api/v1/wallet

{<br>
walletId: UUID, <br>
operationType: DEPOSIT or WITHDRAW, <br>
amount: 1000 <br>
}

после выполнять логику по изменению счета в базе данных

**также есть возможность получить баланс кошелька**
GET api/v1/wallets/{WALLET_UUID}

стек:
- Golang
- Postgresql
- Docker

Обратите особое внимание проблемам при работе в конкурентной среде (1000 RPS по одному кошельку). Ни один запрос не должен быть не обработан (50Х error)

приложение должно запускаться в докер контейнере, база данных тоже, вся система должна подниматься с помощью docker-compose

Необходимо покрыть приложение тестами
Решенное задание залить на гитхаб, предоставить ссылку

Переменные окружения должны считываться из файла config.env.


Все возникающие вопросы по заданию решать самостоятельно, по своему усмотрению.


# Как запустить? 
По умолчанию, запускаестя из Docker (чтобы БД сделать). Клонируйте репозиторий --> выполните команду `docker compose --env-file config.env up --build -d`. 

**Важно!** если после сборки контейнер с сервером не подключиться к БД, то просто перезапустите его. Как я понял, это частая проблема, но как пофиксить - пока не разобрался

Для запуска без Docker -->  нужно в <u>файле envs.go</u> убрать комментарии с строк кода (там помечено, где именно) и в <u>config.env</u> поменять POSTGRES_HOST на localhost.

После запуска, для просмотра документации, перейдите по http://localhost:8000/swagger/index.html


# Что я не знал из этого?
**вот эту часть:** "Обратите особое внимание проблемам при работе в конкурентной среде (1000 RPS по одному кошельку). Ни один запрос не должен быть не обработан (50Х error)"

Как я понял, тут речь про транзакции - грязное чтение, потерянную запись и фантомы.

До этого, я читао про ACID, но в коде еще не отражал. Да и с SQL особо не работал. 

**и еще:** "Необходимо покрыть приложение тестами"

Прежде, тестировал http сервер сам, через Postman, а не через тесты в Go.

# Как думал делать? 
Делать решил через фреймворк GIN. Что касаестя базы данных и SQL, задание прислали как раз, когда изучал данную тему. В моем рапоряжении была книга по Postgresql с сайта оф. документации. 

От себя добавил сваггер и запрос для создания кошелька.

# Выполнение
**POST api/v1/wallet**
- было понимание как писать обработчик, судя по заданию, нужные данные приходят в теле запроса.
- вся сложность для меня была в взаимодействии с базой. Решил через `FOR UPDATE` + транзакция c уровнем изоляции Read Committed (дефолтная для Postgres). Я думал про Serializable изоляцию, но не стал, в задании не сказано, что настолько строго надо. **Получаем** - идет транзакция и если, в этот момент, придет GET запрос, то он вернет баланс, который был ДО начала транзакции. Если придет еще один запрос на операцию, то он встанет в очередь и будет ждать, пока транзакция до него не завершиться. 
- Как я проверил? Добавил `time.Sleep(time.Second * 10)` в транзакцию и через Postman запустил сразу 5 запросов на операцию и еще 2 на получение баланса. POST запросы отработали по очереди, а GET запросы показали последний известный баланс (в GET запросе транзакции не использовались).

**Ни один запрос не должен быть не обработан (50Х error)** - я понял это так: сервер не должен вернуть 500-ые коды, т.е. каждый SQL запрос должен отработать, следуя логике - баланс позволяет, списываем; на балансе нет нужной суммы для операции, возвращаем 400 ответ сервера. 

**Приложение должно запускаться в докер контейнере** - есть упаковка в Docker. Два контейнера, база данных и сервер. У сервера многоступенчатая сборка (чтобы уменьшить размер образа).

**Необходимо покрыть приложение тестами** - есть пакет tests. Первый раз сделал тесты для http-сервера. Именно на тесты ушло больше всего времени, чем на все остальное. **Важно!** Для корректности тестов, сервер нужно запустить, хотя бы 1 раз, чтобы миграция прошла и создалась таблица. Для тестирования, по хорошему, нужна отдельная таблица, но тут всё в одной.

**Переменные окружения должны считываться из файла config.env** - есть файл config.env.